<style>
    * {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #000;
    }
    canvas {
        width: 100%;
        height: 100vh;
        display: block;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
    .controls {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 10px;
        font-family: Arial, sans-serif;
        color: white;
        z-index: 100;
        display: flex;
        gap: 12px;
        backdrop-filter: blur(5px);
    }
    .controls button {
        background: linear-gradient(45deg, rgba(255,255,255,0.1), rgba(255,255,255,0.3));
        color: white;
        border: 1px solid rgba(255,255,255,0.5);
        border-radius: 6px;
        padding: 6px 12px;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    .controls button:hover {
        background: linear-gradient(45deg, rgba(255,255,255,0.3), rgba(255,255,255,0.5));
        transform: scale(1.05);
    }
    </style>
    
    <div class="controls">
        <button id="chainReaction">Chain Reaction</button>
        <button id="toggleAudio">Toggle Audio</button>
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
            "three/addons/controls/OrbitControls.js": "https://unpkg.com/three@0.162.0/examples/jsm/controls/OrbitControls.js",
            "three/addons/postprocessing/EffectComposer.js": "https://unpkg.com/three@0.162.0/examples/jsm/postprocessing/EffectComposer.js",
            "three/addons/postprocessing/RenderPass.js": "https://unpkg.com/three@0.162.0/examples/jsm/postprocessing/RenderPass.js",
            "three/addons/postprocessing/UnrealBloomPass.js": "https://unpkg.com/three@0.162.0/examples/jsm/postprocessing/UnrealBloomPass.js",
            "three/addons/postprocessing/ShaderPass.js": "https://unpkg.com/three@0.162.0/examples/jsm/postprocessing/ShaderPass.js"
        }
    }
    </script>
    
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    
    let audioContext;
    let audioEnabled = false;
    const toggleAudioButton = document.getElementById('toggleAudio');
    toggleAudioButton.addEventListener('click', () => {
        if (!audioContext) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioEnabled = true;
                toggleAudioButton.textContent = "Audio: ON";
            } catch (e) {
                console.error("Web Audio API not supported:", e);
            }
        } else {
            audioEnabled = !audioEnabled;
            toggleAudioButton.textContent = audioEnabled ? "Audio: ON" : "Audio: OFF";
        }
    });
    
    function playSound(type, frequency, duration) {
        if (!audioContext || !audioEnabled) return;
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        
        oscillator.frequency.exponentialRampToValueAtTime(
            frequency * (0.95 + Math.random() * 0.1),
            audioContext.currentTime + duration * 0.5
        );
        
        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration + 0.5);
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + duration + 0.5);
    }
    
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x111133, 0.01);
    scene.background = new THREE.Color(0x000022);
    
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 10, 20);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.body.appendChild(renderer.domElement);
    
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.4,
        0.3,
        0.85
    );
    composer.addPass(bloomPass);
    
    const vignetteShader = {
        uniforms: {
            'tDiffuse': { value: null },
            'offset': { value: 1.0 },
            'darkness': { value: 1.2 },
            'time': { value: 0 }
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform float offset;
            uniform float darkness;
            uniform float time;
            varying vec2 vUv;
            void main() {
                vec4 texel = texture2D(tDiffuse, vUv);
                vec2 uv = (vUv - vec2(0.5)) * vec2(offset);
                float dist = dot(uv, uv) * darkness;
                dist += sin(time * 0.1) * 0.02;
                gl_FragColor = vec4(mix(texel.rgb, vec3(0.0), dist), texel.a);
            }
        `
    };
    const vignettePass = new ShaderPass(vignetteShader);
    composer.addPass(vignettePass);
    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxDistance = 50;
    controls.minDistance = 5;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;
    
    const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    scene.add(dirLight);
    
    const pointLight = new THREE.PointLight(0xffaa00, 1.2, 50);
    pointLight.position.set(-10, 10, -10);
    scene.add(pointLight);
    
    const blueLight = new THREE.PointLight(0x0066ff, 0.8, 40);
    blueLight.position.set(15, -10, 15);
    scene.add(blueLight);
    
    function createAtmosphere() {
        const particleCount = 1200;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const speeds = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
            const radius = 20 + Math.random() * 80;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[i * 3 + 2] = radius * Math.cos(phi);
            
            sizes[i] = 0.1 + Math.random() * 0.2;
            speeds[i] = 0.01 + Math.random() * 0.04;
            
            const hue = Math.random();
            const saturation = 0.7 + Math.random() * 0.3;
            const lightness = 0.6 + Math.random() * 0.4;
            const color = new THREE.Color().setHSL(hue, saturation, lightness);
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const material = new THREE.PointsMaterial({
            size: 0.2,
            vertexColors: true,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        const particles = new THREE.Points(geometry, material);
        particles.userData = { speeds };
        
        return particles;
    }
    
    const atmosphere = createAtmosphere();
    scene.add(atmosphere);
    
    const sphereShader = {
        uniforms: {
            time: { value: 0 },
            color: { value: new THREE.Color(0x00ffcc) },
            activationTime: { value: -1 },
            activationDuration: { value: 1.2 }
        },
        vertexShader: `
            uniform float time;
            uniform float activationTime;
            uniform float activationDuration;
            varying vec3 vNormal;
            varying vec2 vUv;
            varying float vActivation;
            
            void main() {
                vNormal = normal;
                vUv = uv;
                float elapsed = time - activationTime;
                float strength = max(0.0, 1.0 - elapsed / activationDuration);
                vActivation = strength;
                
                float breathing = sin(time * 1.5 + position.x * 0.5) * 0.03;
                
                vec3 pos = position + normal * (
                    sin(time * 2.0 + position.x * 5.0) * 0.1 * (1.0 + strength * 3.0) + 
                    breathing
                );
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 color;
            uniform float time;
            varying vec3 vNormal;
            varying vec2 vUv;
            varying float vActivation;
            
            void main() {
                float rimLight = pow(0.8 - dot(vNormal, vec3(0, 0, 1)), 2.0);
                
                float pattern = sin(vUv.x * 20.0) * sin(vUv.y * 20.0) * 0.05;
                float pulse = 0.8 + 0.2 * sin(time * 3.0);
                
                vec3 baseColor = color * (rimLight + 0.3) * pulse + pattern;
                vec3 activationColor = vec3(1.0, 0.5, 0.0) * vActivation * 2.0;
                
                gl_FragColor = vec4(baseColor + activationColor, 1.0);
            }
        `
    };
    
    const spheres = createSpheres();
    scene.add(...spheres);
    
    function createSpheres() {
        const spheres = [];
        const sphereCount = 110;
        const radius = 10;
        
        for (let i = 0; i < sphereCount; i++) {
            const phi = Math.acos(1 - 2 * (i + 0.5) / sphereCount);
            const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
            
            const x = radius * Math.cos(theta) * Math.sin(phi);
            const y = radius * Math.sin(theta) * Math.sin(phi);
            const z = radius * Math.cos(phi);
            
            const hue = i / sphereCount;
            const color = new THREE.Color().setHSL(hue, 0.85, 0.5);
            const geometry = new THREE.SphereGeometry(0.4, 32, 32);
            const material = new THREE.ShaderMaterial({
                ...sphereShader,
                uniforms: THREE.UniformsUtils.clone(sphereShader.uniforms)
            });
            material.uniforms.color.value = color;
            
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            sphere.userData = { 
                color, 
                neighbors: [], 
                activated: false,
                initialPosition: new THREE.Vector3(x, y, z)
            };
            spheres.push(sphere);
        }
        
        const distanceThreshold = 5;
        spheres.forEach(sphere => {
            spheres.forEach(other => {
                if (sphere !== other && sphere.position.distanceTo(other.position) < distanceThreshold) {
                    sphere.userData.neighbors.push(other);
                }
            });
        });
        
        return spheres;
    }
    
    function createParticles(position, color) {
        const particleCount = 60;
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const velocities = [];
        
        for (let i = 0; i < particleCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const r = 0.2 + Math.random() * 0.3;
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            
            positions.push(x, y, z);
            
            const particleColor = color.clone();
            particleColor.offsetHSL(Math.random() * 0.1 - 0.05, 0, Math.random() * 0.2);
            colors.push(particleColor.r, particleColor.g, particleColor.b);
            
            velocities.push(
                (Math.random() - 0.5) * 0.15,
                (Math.random() - 0.5) * 0.15,
                (Math.random() - 0.5) * 0.15
            );
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        const material = new THREE.PointsMaterial({
            size: 0.3,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        const particles = new THREE.Points(geometry, material);
        particles.position.copy(position);
        particles.userData = { 
            velocities,
            startTime: performance.now() * 0.001
        };
        scene.add(particles);
        
        function updateParticles() {
            const elapsed = (performance.now() * 0.001 - particles.userData.startTime);
            
            if (elapsed > 1.2) {
                scene.remove(particles);
                geometry.dispose();
                material.dispose();
                return;
            }
            
            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.userData.velocities;
            
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] += velocities[i/3 * 3] * (1 + elapsed);
                positions[i+1] += velocities[i/3 * 3 + 1] * (1 + elapsed) + 0.01;
                positions[i+2] += velocities[i/3 * 3 + 2] * (1 + elapsed);
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            material.opacity = 0.8 * (1 - elapsed / 1.2);
            
            requestAnimationFrame(updateParticles);
        }
        updateParticles();
        
        playSound(
            ['sine', 'triangle', 'sawtooth'][Math.floor(Math.random() * 3)],
            200 + Math.random() * 500, 
            0.6
        );
    }
    
    document.getElementById('chainReaction').addEventListener('click', startChainReaction);
    
    function startChainReaction() {
        spheres.forEach(sphere => sphere.userData.activated = false);
        const startSphere = spheres[Math.floor(Math.random() * spheres.length)];
        activateSphere(startSphere, performance.now() * 0.001);
        
        setTimeout(() => {
            spheres.forEach((sphere, index) => {
                if (!sphere.userData.activated) {
                    setTimeout(() => {
                        activateSphere(sphere, performance.now() * 0.001);
                    }, index * 100);
                }
            });
        }, 5000);
    }
    
    function activateSphere(sphere, time) {
        if (sphere.userData.activated) return;
        sphere.userData.activated = true;
        sphere.material.uniforms.activationTime.value = time;
        createParticles(sphere.position, sphere.userData.color);
        
        sphere.userData.neighbors.forEach((neighbor, i) => {
            const delay = 80 + Math.random() * 100;
            setTimeout(() => {
                activateSphere(neighbor, time + 0.1 * (i + 1));
            }, delay);
        });
    }
    
    let lastTime = 0;
    function animate(currentTime) {
        requestAnimationFrame(animate);
        
        const time = currentTime * 0.001;
        const delta = Math.min(time - lastTime, 0.1);
        lastTime = time;
        
        spheres.forEach(sphere => {
            sphere.material.uniforms.time.value = time;
            
            if (!sphere.userData.activated) {
                const initialPos = sphere.userData.initialPosition;
                sphere.position.x = initialPos.x + Math.sin(time * 0.5 + initialPos.x) * 0.05;
                sphere.position.y = initialPos.y + Math.sin(time * 0.6 + initialPos.y) * 0.05;
                sphere.position.z = initialPos.z + Math.sin(time * 0.7 + initialPos.z) * 0.05;
            }
        });
        
        vignettePass.uniforms.time.value = time;
        
        if (atmosphere.geometry.attributes.position) {
            const positions = atmosphere.geometry.attributes.position.array;
            const speeds = atmosphere.userData.speeds;
            
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i + 2];
                const speed = speeds[i / 3] * delta;
                
                const newX = x * Math.cos(speed) - z * Math.sin(speed);
                const newZ = x * Math.sin(speed) + z * Math.cos(speed);
                
                positions[i] = newX;
                positions[i + 2] = newZ;
                
                positions[i + 1] += Math.sin(time * 0.5 + i * 0.01) * 0.01;
            }
            
            atmosphere.geometry.attributes.position.needsUpdate = true;
        }
        
        blueLight.position.x = 15 * Math.cos(time * 0.2);
        blueLight.position.z = 15 * Math.sin(time * 0.2);
        
        atmosphere.rotation.y += 0.001;
        
        controls.update();
        composer.render();
    }
    
    animate(0);
    
    window.addEventListener('resize', () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        composer.setSize(width, height);
    });
    
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    renderer.domElement.addEventListener('click', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(spheres);
        
        if (intersects.length > 0) {
            activateSphere(intersects[0].object, performance.now() * 0.001);
        }
    });
    </script>